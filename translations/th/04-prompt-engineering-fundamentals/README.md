<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b3cb38518cf4fe7714d2f5e74dfa3eb",
  "translation_date": "2025-10-03T09:31:51+00:00",
  "source_file": "04-prompt-engineering-fundamentals/README.md",
  "language_code": "th"
}
-->
# พื้นฐานการออกแบบคำสั่ง (Prompt Engineering)

[![พื้นฐานการออกแบบคำสั่ง](../../../translated_images/04-lesson-banner.a2c90deba7fedacda69f35b41636a8951ec91c2e33f5420b1254534ac85bc18e.th.png)](https://aka.ms/gen-ai-lesson4-gh?WT.mc_id=academic-105485-koreyst)

## บทนำ
โมดูลนี้ครอบคลุมแนวคิดและเทคนิคสำคัญสำหรับการสร้างคำสั่งที่มีประสิทธิภาพในโมเดล AI เชิงสร้างสรรค์ (Generative AI) วิธีการเขียนคำสั่ง (prompt) ให้กับ LLM มีความสำคัญมาก คำสั่งที่ถูกออกแบบมาอย่างดีสามารถให้ผลลัพธ์ที่มีคุณภาพดีกว่า แต่คำว่า _prompt_ และ _prompt engineering_ หมายถึงอะไร? และเราจะปรับปรุงคำสั่ง _input_ ที่ส่งไปยัง LLM ได้อย่างไร? คำถามเหล่านี้จะได้รับคำตอบในบทนี้และบทถัดไป

_Generative AI_ มีความสามารถในการสร้างเนื้อหาใหม่ (เช่น ข้อความ รูปภาพ เสียง โค้ด ฯลฯ) ตามคำขอของผู้ใช้ โดยใช้ _Large Language Models_ เช่น GPT ("Generative Pre-trained Transformer") ของ OpenAI ซึ่งได้รับการฝึกฝนให้ใช้ภาษาธรรมชาติและโค้ด

ผู้ใช้สามารถโต้ตอบกับโมเดลเหล่านี้ได้ผ่านรูปแบบที่คุ้นเคย เช่น การแชท โดยไม่จำเป็นต้องมีความเชี่ยวชาญทางเทคนิคหรือการฝึกอบรม โมเดลเหล่านี้เป็น _prompt-based_ - ผู้ใช้ส่งข้อความ (prompt) และได้รับการตอบกลับจาก AI (completion) จากนั้นสามารถ "แชทกับ AI" ได้อย่างต่อเนื่องในบทสนทนาแบบหลายรอบ โดยปรับแต่งคำสั่งจนกว่าผลลัพธ์จะตรงกับความคาดหวัง

"คำสั่ง" กลายเป็น _อินเทอร์เฟซการเขียนโปรแกรม_ หลักสำหรับแอปพลิเคชัน AI เชิงสร้างสรรค์ โดยบอกโมเดลว่าต้องทำอะไรและมีผลต่อคุณภาพของผลลัพธ์ที่ได้ "Prompt Engineering" เป็นสาขาการศึกษาที่เติบโตอย่างรวดเร็ว ซึ่งมุ่งเน้นไปที่ _การออกแบบและการปรับปรุง_ คำสั่งเพื่อให้ได้ผลลัพธ์ที่มีคุณภาพและสม่ำเสมอในระดับใหญ่

## เป้าหมายการเรียนรู้

ในบทเรียนนี้ เราจะเรียนรู้ว่า Prompt Engineering คืออะไร ทำไมมันถึงสำคัญ และเราจะสร้างคำสั่งที่มีประสิทธิภาพมากขึ้นสำหรับโมเดลและเป้าหมายของแอปพลิเคชันได้อย่างไร เราจะเข้าใจแนวคิดหลักและแนวปฏิบัติที่ดีที่สุดสำหรับการออกแบบคำสั่ง - และเรียนรู้เกี่ยวกับสภาพแวดล้อม "sandbox" ใน Jupyter Notebooks ที่เราสามารถเห็นการนำแนวคิดเหล่านี้ไปใช้กับตัวอย่างจริง

เมื่อจบบทเรียนนี้ เราจะสามารถ:

1. อธิบายว่า Prompt Engineering คืออะไรและทำไมมันถึงสำคัญ
2. อธิบายองค์ประกอบของคำสั่งและวิธีการใช้งาน
3. เรียนรู้แนวปฏิบัติและเทคนิคที่ดีที่สุดสำหรับการออกแบบคำสั่ง
4. นำเทคนิคที่เรียนรู้ไปใช้กับตัวอย่างจริง โดยใช้ OpenAI endpoint

## คำศัพท์สำคัญ

Prompt Engineering: การออกแบบและปรับปรุงคำสั่งเพื่อชี้นำโมเดล AI ให้สร้างผลลัพธ์ตามที่ต้องการ  
Tokenization: กระบวนการแปลงข้อความเป็นหน่วยย่อยที่เรียกว่าโทเค็น ซึ่งโมเดลสามารถเข้าใจและประมวลผลได้  
Instruction-Tuned LLMs: โมเดลภาษาใหญ่ (LLMs) ที่ได้รับการปรับแต่งด้วยคำสั่งเฉพาะเพื่อปรับปรุงความแม่นยำและความเกี่ยวข้องของการตอบสนอง  

## Learning Sandbox

การออกแบบคำสั่งในปัจจุบันยังคงเป็นศิลปะมากกว่าวิทยาศาสตร์ วิธีที่ดีที่สุดในการพัฒนาสัญชาตญาณสำหรับมันคือ _การฝึกฝนมากขึ้น_ และใช้วิธีการลองผิดลองถูกที่ผสมผสานความเชี่ยวชาญในโดเมนแอปพลิเคชันกับเทคนิคที่แนะนำและการปรับแต่งเฉพาะโมเดล

Jupyter Notebook ที่มาพร้อมกับบทเรียนนี้ให้สภาพแวดล้อม _sandbox_ ที่คุณสามารถลองสิ่งที่คุณเรียนรู้ - ทั้งในระหว่างการเรียนหรือเป็นส่วนหนึ่งของการท้าทายโค้ดในตอนท้าย ในการดำเนินการแบบฝึกหัด คุณจะต้อง:

1. **Azure OpenAI API key** - endpoint บริการสำหรับโมเดล LLM ที่ปรับใช้แล้ว  
2. **Python Runtime** - ที่สามารถรัน Notebook ได้  
3. **Local Env Variables** - _ทำตามขั้นตอน [SETUP](./../00-course-setup/02-setup-local.md?WT.mc_id=academic-105485-koreyst) เพื่อเตรียมความพร้อม_  

Notebook มาพร้อมกับแบบฝึกหัด _เริ่มต้น_ - แต่คุณได้รับการสนับสนุนให้เพิ่มส่วน _Markdown_ (คำอธิบาย) และ _Code_ (คำสั่ง) ของคุณเองเพื่อทดลองตัวอย่างหรือไอเดียเพิ่มเติม - และสร้างสัญชาตญาณสำหรับการออกแบบคำสั่ง

## คู่มือภาพประกอบ

ต้องการเห็นภาพรวมของสิ่งที่บทเรียนนี้ครอบคลุมก่อนที่จะเริ่มต้นใช่ไหม? ลองดูคู่มือภาพประกอบนี้ ซึ่งให้ความเข้าใจเกี่ยวกับหัวข้อหลักที่ครอบคลุมและประเด็นสำคัญที่คุณควรคิดถึงในแต่ละหัวข้อ แผนที่บทเรียนจะนำคุณจากการทำความเข้าใจแนวคิดและความท้าทายหลักไปสู่การแก้ไขด้วยเทคนิคและแนวปฏิบัติที่ดีที่สุดสำหรับการออกแบบคำสั่ง โปรดทราบว่าส่วน "Advanced Techniques" ในคู่มือนี้อ้างถึงเนื้อหาที่ครอบคลุมในบทถัดไปของหลักสูตรนี้

![คู่มือภาพประกอบสำหรับการออกแบบคำสั่ง](../../../translated_images/04-prompt-engineering-sketchnote.d5f33336957a1e4f623b826195c2146ef4cc49974b72fa373de6929b474e8b70.th.png)

## สตาร์ทอัพของเรา

ตอนนี้ มาพูดถึงว่า _หัวข้อนี้_ เกี่ยวข้องกับภารกิจของสตาร์ทอัพของเราในการ [นำ AI มาสู่การศึกษา](https://educationblog.microsoft.com/2023/06/collaborating-to-bring-ai-innovation-to-education?WT.mc_id=academic-105485-koreyst) อย่างไร เราต้องการสร้างแอปพลิเคชันที่ขับเคลื่อนด้วย AI สำหรับ _การเรียนรู้แบบเฉพาะบุคคล_ - ดังนั้นลองคิดดูว่าผู้ใช้ต่างๆ ของแอปพลิเคชันของเราอาจ "ออกแบบ" คำสั่งอย่างไร:

- **ผู้ดูแลระบบ** อาจขอให้ AI _วิเคราะห์ข้อมูลหลักสูตรเพื่อระบุช่องว่างในเนื้อหา_ AI สามารถสรุปผลลัพธ์หรือแสดงภาพด้วยโค้ด  
- **ครูผู้สอน** อาจขอให้ AI _สร้างแผนการสอนสำหรับกลุ่มเป้าหมายและหัวข้อที่กำหนด_ AI สามารถสร้างแผนเฉพาะบุคคลในรูปแบบที่ระบุ  
- **นักเรียน** อาจขอให้ AI _สอนพวกเขาในวิชาที่ยาก_ AI สามารถแนะนำบทเรียน คำใบ้ และตัวอย่างที่ปรับให้เหมาะสมกับระดับของนักเรียน  

นี่เป็นเพียงจุดเริ่มต้นเท่านั้น ลองดู [Prompts For Education](https://github.com/microsoft/prompts-for-edu/tree/main?WT.mc_id=academic-105485-koreyst) - ไลบรารีคำสั่งแบบโอเพ่นซอร์สที่รวบรวมโดยผู้เชี่ยวชาญด้านการศึกษา - เพื่อให้เห็นถึงความเป็นไปได้ที่กว้างขึ้น! _ลองรันคำสั่งเหล่านั้นใน sandbox หรือใช้ OpenAI Playground เพื่อดูผลลัพธ์!_

<!--
LESSON TEMPLATE:
This unit should cover core concept #1.
Reinforce the concept with examples and references.

CONCEPT #1:
Prompt Engineering.
Define it and explain why it is needed.
-->

## Prompt Engineering คืออะไร?

เราเริ่มบทเรียนนี้ด้วยการนิยาม **Prompt Engineering** ว่าเป็นกระบวนการ _ออกแบบและปรับปรุง_ ข้อความคำสั่ง (prompts) เพื่อให้ได้ผลลัพธ์ที่สม่ำเสมอและมีคุณภาพ (completions) สำหรับเป้าหมายของแอปพลิเคชันและโมเดลที่กำหนด เราสามารถคิดถึงสิ่งนี้เป็นกระบวนการ 2 ขั้นตอน:

- _ออกแบบ_ คำสั่งเริ่มต้นสำหรับโมเดลและเป้าหมายที่กำหนด  
- _ปรับปรุง_ คำสั่งอย่างต่อเนื่องเพื่อเพิ่มคุณภาพของผลลัพธ์  

นี่เป็นกระบวนการที่ต้องใช้การลองผิดลองถูก ซึ่งต้องการสัญชาตญาณและความพยายามจากผู้ใช้เพื่อให้ได้ผลลัพธ์ที่ดีที่สุด แล้วทำไมมันถึงสำคัญ? เพื่อที่จะตอบคำถามนั้น เราต้องเข้าใจแนวคิดสามประการ:

- _Tokenization_ = วิธีที่โมเดล "มองเห็น" คำสั่ง  
- _Base LLMs_ = วิธีที่โมเดลพื้นฐาน "ประมวลผล" คำสั่ง  
- _Instruction-Tuned LLMs_ = วิธีที่โมเดลสามารถมองเห็น "งาน"  

### Tokenization

LLM มองคำสั่งเป็น _ลำดับของโทเค็น_ ซึ่งโมเดลต่างๆ (หรือเวอร์ชันของโมเดล) อาจแปลงคำสั่งเดียวกันเป็นโทเค็นในรูปแบบที่แตกต่างกัน เนื่องจาก LLMs ได้รับการฝึกฝนด้วยโทเค็น (ไม่ใช่ข้อความดิบ) วิธีที่คำสั่งถูกแปลงเป็นโทเค็นมีผลโดยตรงต่อคุณภาพของผลลัพธ์ที่สร้างขึ้น

เพื่อให้เข้าใจว่า Tokenization ทำงานอย่างไร ลองใช้เครื่องมืออย่าง [OpenAI Tokenizer](https://platform.openai.com/tokenizer?WT.mc_id=academic-105485-koreyst) ที่แสดงด้านล่าง คัดลอกคำสั่งของคุณลงไป - และดูว่ามันถูกแปลงเป็นโทเค็นอย่างไร โดยสังเกตว่าตัวอักษรเว้นวรรคและเครื่องหมายวรรคตอนถูกจัดการอย่างไร โปรดทราบว่าตัวอย่างนี้แสดงโมเดล LLM รุ่นเก่า (GPT-3) - ดังนั้นการลองใช้กับโมเดลใหม่อาจให้ผลลัพธ์ที่แตกต่างกัน

![Tokenization](../../../translated_images/04-tokenizer-example.e71f0a0f70356c5c7d80b21e8753a28c18a7f6d4aaa1c4b08e65d17625e85642.th.png)

### แนวคิด: โมเดลพื้นฐาน

เมื่อคำสั่งถูกแปลงเป็นโทเค็น ฟังก์ชันหลักของ ["Base LLM"](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst) (หรือโมเดลพื้นฐาน) คือการทำนายโทเค็นในลำดับนั้น เนื่องจาก LLMs ได้รับการฝึกฝนด้วยชุดข้อมูลข้อความขนาดใหญ่ พวกเขามีความเข้าใจที่ดีเกี่ยวกับความสัมพันธ์ทางสถิติระหว่างโทเค็นและสามารถทำนายได้ด้วยความมั่นใจในระดับหนึ่ง โปรดทราบว่าพวกเขาไม่ได้เข้าใจ _ความหมาย_ ของคำในคำสั่งหรือโทเค็น; พวกเขาเพียงแค่เห็นรูปแบบที่สามารถ "เติมเต็ม" ด้วยการทำนายครั้งต่อไป พวกเขาสามารถทำนายลำดับต่อไปได้จนกว่าจะถูกยุติโดยการแทรกแซงของผู้ใช้หรือเงื่อนไขที่กำหนดไว้ล่วงหน้า

ต้องการเห็นว่าการเติมเต็มคำสั่งทำงานอย่างไร? ใส่คำสั่งด้านบนลงใน [_Chat Playground_](https://oai.azure.com/playground?WT.mc_id=academic-105485-koreyst) ของ Azure OpenAI Studio ด้วยการตั้งค่าเริ่มต้น ระบบถูกกำหนดค่าให้ปฏิบัติต่อคำสั่งเป็นคำขอข้อมูล - ดังนั้นคุณควรเห็นผลลัพธ์ที่ตอบสนองบริบทนี้

แต่ถ้าผู้ใช้ต้องการเห็นบางสิ่งที่เฉพาะเจาะจงซึ่งตรงกับเกณฑ์หรือเป้าหมายของงานล่ะ? นี่คือจุดที่ _Instruction-Tuned LLMs_ เข้ามามีบทบาท

![Base LLM Chat Completion](../../../translated_images/04-playground-chat-base.65b76fcfde0caa6738e41d20f1a6123f9078219e6f91a88ee5ea8014f0469bdf.th.png)

### แนวคิด: Instruction-Tuned LLMs

[Instruction-Tuned LLM](https://blog.gopenai.com/an-introduction-to-base-and-instruction-tuned-large-language-models-8de102c785a6?WT.mc_id=academic-105485-koreyst) เริ่มต้นด้วยโมเดลพื้นฐานและปรับแต่งด้วยตัวอย่างหรือคู่ input/output (เช่น "ข้อความ" แบบหลายรอบ) ที่สามารถมีคำสั่งที่ชัดเจน - และการตอบสนองจาก AI พยายามปฏิบัติตามคำสั่งนั้น

สิ่งนี้ใช้เทคนิคอย่าง Reinforcement Learning with Human Feedback (RLHF) ที่สามารถฝึกโมเดลให้ _ปฏิบัติตามคำสั่ง_ และ _เรียนรู้จากข้อเสนอแนะ_ เพื่อให้สร้างผลลัพธ์ที่เหมาะสมกับการใช้งานจริงและเกี่ยวข้องกับเป้าหมายของผู้ใช้มากขึ้น

ลองดู - กลับไปที่คำสั่งด้านบน แต่ตอนนี้เปลี่ยน _ข้อความระบบ_ เพื่อให้คำสั่งต่อไปนี้เป็นบริบท:

> _สรุปเนื้อหาที่คุณได้รับสำหรับนักเรียนชั้นประถมศึกษาปีที่ 2 โดยให้ผลลัพธ์เป็นหนึ่งย่อหน้าที่มี 3-5 หัวข้อย่อย_

ดูว่าผลลัพธ์ตอนนี้ถูกปรับให้สะท้อนเป้าหมายและรูปแบบที่ต้องการหรือไม่? ครูผู้สอนสามารถใช้ผลลัพธ์นี้ในสไลด์สำหรับชั้นเรียนได้โดยตรง

![Instruction Tuned LLM Chat Completion](../../../translated_images/04-playground-chat-instructions.b30bbfbdf92f2d051639c9bc23f74a0e2482f8dc7f0dafc6cc6fda81b2b00534.th.png)

## ทำไมเราต้องการ Prompt Engineering?

ตอนนี้เรารู้แล้วว่าคำสั่งถูกประมวลผลโดย LLMs อย่างไร มาพูดถึง _ทำไม_ เราต้องการ Prompt Engineering คำตอบอยู่ในความจริงที่ว่า LLMs ในปัจจุบันมีความท้าทายหลายประการที่ทำให้ _การเติมเต็มที่เชื่อถือได้และสม่ำเสมอ_ ยากขึ้นหากไม่มีการใส่ความพยายามในการสร้างและปรับปรุงคำสั่ง ตัวอย่างเช่น:

1. **การตอบสนองของโมเดลเป็นแบบสุ่ม** คำสั่ง _เดียวกัน_ อาจให้ผลลัพธ์ที่แตกต่างกันกับโมเดลหรือเวอร์ชันของโมเดลที่แตกต่างกัน และอาจให้ผลลัพธ์ที่แตกต่างกันแม้ใช้ _โมเดลเดียวกัน_ ในเวลาที่ต่างกัน _เทคนิคการออกแบบคำสั่งสามารถช่วยลดความแปรปรวนเหล่านี้โดยการให้กรอบการทำงานที่ดีขึ้น_

2. **โมเดลสามารถสร้างข้อมูลที่ไม่ถูกต้อง** โมเดลได้รับการฝึกฝนด้วยชุดข้อมูล _ขนาดใหญ่แต่มีขอบเขตจำกัด_ ซึ่งหมายความว่าพวกเขาขาดความรู้เกี่ยวกับแนวคิดที่อยู่นอกเหนือขอบเขตการฝึกฝน ดังนั้นพวกเขาอาจสร้างผลลัพธ์ที่ไม่ถูกต้อง จินตนาการ หรือขัดแย้งกับข้อเท็จจริงที่ทราบ _เทคนิคการออกแบบคำสั่งช่วยให้ผู้ใช้ระบุและลดการสร้างข้อมูลที่ไม่ถูกต้อง เช่น โดยการขอให้ AI อ้างอิงหรือให้เหตุผล_

3. **ความสามารถของโมเดลจะแตกต่างกัน** โมเดลใหม่หรือรุ่นใหม่จะมีความสามารถที่หลากหลายมากขึ้น แต่ก็นำมาซึ่งลักษณะเฉพาะและข้อแลกเปลี่ยนในด้านต้นทุนและความซับซ้อน _การออกแบบคำสั่งสามารถช่วยพัฒนาแนวปฏิบัติและกระบวนการทำงานที่ลดความแตกต่างและปรับให้เข้ากับข้อกำหนดเฉพาะของโมเดลในวิธีที่ปรับขนาดได้และราบรื่น_

ลองดูตัวอย่างนี้ใน OpenAI หรือ Azure OpenAI Playground:

- ใช้คำสั่งเดียวกันกับการปรับใช้ LLM ที่แตกต่างกัน (เช่น OpenAI, Azure OpenAI, Hugging Face) - คุณเห็นความแตกต่างหรือไม่?  
- ใช้คำสั่งเดียวกันซ้ำๆ กับการปรับใช้ LLM _เดียวกัน_ (เช่น Azure OpenAI Playground) - ความแตกต่างเหล่านี้แตกต่างกันอย่างไร?  

### ตัวอย่างการสร้างข้อมูลที่ไม่ถูกต้อง

ในหลักสูตรนี้ เราใช้คำว่า **"การสร้างข้อมูลที่ไม่ถูกต้อง"** เพื่ออ้างถึงปรากฏการณ์ที่ LLMs บางครั้งสร้างข้อมูลที่ไม่ถูกต้องเนื่องจากข้อจำกัดในการฝึกฝนหรือข้อจำกัดอื่นๆ คุณอาจเคยได้ยินคำนี้ในชื่อ _"hallucinations"_ ในบทความหรือเอกสารวิจัย อย่างไรก็ตาม เราขอแนะนำให้ใช้คำว่า _"การสร้างข้อมูลที่ไม่ถูกต้อง"_ เพื่อหลีกเลี่ยงการทำให้พฤติกรรมดูเหมือนมนุษย์โดยการให้ลักษณะของมนุษย์กับ
การค้นหาในเว็บแสดงให้เห็นว่ามีเรื่องราวสมมติ (เช่น ซีรีส์โทรทัศน์หรือหนังสือ) เกี่ยวกับสงครามบนดาวอังคาร - แต่ไม่มีเหตุการณ์ใดในปี 2076 สามัญสำนึกบอกเราว่า ปี 2076 เป็น _อนาคต_ และดังนั้นจึงไม่สามารถเชื่อมโยงกับเหตุการณ์จริงได้

แล้วจะเกิดอะไรขึ้นเมื่อเราทดลองใช้คำสั่งนี้กับผู้ให้บริการ LLM ต่างๆ?

> **คำตอบที่ 1**: OpenAI Playground (GPT-35)

![คำตอบที่ 1](../../../translated_images/04-fabrication-oai.5818c4e0b2a2678c40e0793bf873ef4a425350dd0063a183fb8ae02cae63aa0c.th.png)

> **คำตอบที่ 2**: Azure OpenAI Playground (GPT-35)

![คำตอบที่ 2](../../../translated_images/04-fabrication-aoai.b14268e9ecf25caf613b7d424c16e2a0dc5b578f8f960c0c04d4fb3a68e6cf61.th.png)

> **คำตอบที่ 3**: Hugging Face Chat Playground (LLama-2)

![คำตอบที่ 3](../../../translated_images/04-fabrication-huggingchat.faf82a0a512789565e410568bce1ac911075b943dec59b1ef4080b61723b5bf4.th.png)

ตามที่คาดไว้ แต่ละโมเดล (หรือเวอร์ชันของโมเดล) สร้างคำตอบที่แตกต่างกันเล็กน้อยเนื่องจากพฤติกรรมแบบสุ่มและความสามารถของโมเดลที่แตกต่างกัน ตัวอย่างเช่น โมเดลหนึ่งมุ่งเป้าไปที่ผู้เรียนระดับมัธยมต้น ในขณะที่อีกโมเดลหนึ่งสมมติว่าผู้ใช้เป็นนักเรียนมัธยมปลาย แต่ทั้งสามโมเดลสร้างคำตอบที่สามารถโน้มน้าวผู้ใช้ที่ไม่มีข้อมูลว่าเหตุการณ์นั้นเป็นเรื่องจริง

เทคนิคการออกแบบคำสั่ง เช่น _metaprompting_ และ _temperature configuration_ อาจลดการสร้างข้อมูลเท็จของโมเดลได้ในระดับหนึ่ง สถาปัตยกรรมใหม่ของการออกแบบคำสั่งยังรวมเครื่องมือและเทคนิคใหม่ๆ เข้ากับกระบวนการคำสั่งอย่างไร้รอยต่อ เพื่อลดหรือบรรเทาผลกระทบบางประการ

## กรณีศึกษา: GitHub Copilot

เรามาปิดท้ายส่วนนี้ด้วยการทำความเข้าใจว่าเทคนิคการออกแบบคำสั่งถูกนำไปใช้ในโซลูชันจริงอย่างไร โดยดูจากกรณีศึกษา: [GitHub Copilot](https://github.com/features/copilot?WT.mc_id=academic-105485-koreyst)

GitHub Copilot คือ "AI คู่หูโปรแกรมเมอร์" ของคุณ - มันแปลงคำสั่งข้อความเป็นการเติมโค้ด และถูกรวมเข้ากับสภาพแวดล้อมการพัฒนาของคุณ (เช่น Visual Studio Code) เพื่อประสบการณ์การใช้งานที่ไร้รอยต่อ ตามที่ได้บันทึกไว้ในชุดบล็อกด้านล่าง เวอร์ชันแรกสุดนั้นอิงจากโมเดล OpenAI Codex - โดยวิศวกรได้ตระหนักถึงความจำเป็นในการปรับแต่งโมเดลและพัฒนาเทคนิคการออกแบบคำสั่งที่ดียิ่งขึ้น เพื่อปรับปรุงคุณภาพของโค้ด ในเดือนกรกฎาคม พวกเขา [เปิดตัวโมเดล AI ที่ปรับปรุงใหม่ซึ่งก้าวข้าม Codex](https://github.blog/2023-07-28-smarter-more-efficient-coding-github-copilot-goes-beyond-codex-with-improved-ai-model/?WT.mc_id=academic-105485-koreyst) เพื่อการแนะนำที่รวดเร็วยิ่งขึ้น

อ่านโพสต์ตามลำดับเพื่อติดตามเส้นทางการเรียนรู้ของพวกเขา

- **พฤษภาคม 2023** | [GitHub Copilot กำลังเข้าใจโค้ดของคุณได้ดีขึ้น](https://github.blog/2023-05-17-how-github-copilot-is-getting-better-at-understanding-your-code/?WT.mc_id=academic-105485-koreyst)
- **พฤษภาคม 2023** | [ภายใน GitHub: การทำงานกับ LLMs ที่อยู่เบื้องหลัง GitHub Copilot](https://github.blog/2023-05-17-inside-github-working-with-the-llms-behind-github-copilot/?WT.mc_id=academic-105485-koreyst)
- **มิถุนายน 2023** | [วิธีเขียนคำสั่งที่ดีกว่าสำหรับ GitHub Copilot](https://github.blog/2023-06-20-how-to-write-better-prompts-for-github-copilot/?WT.mc_id=academic-105485-koreyst)
- **กรกฎาคม 2023** | [GitHub Copilot ก้าวข้าม Codex ด้วยโมเดล AI ที่ปรับปรุงใหม่](https://github.blog/2023-07-28-smarter-more-efficient-coding-github-copilot-goes-beyond-codex-with-improved-ai-model/?WT.mc_id=academic-105485-koreyst)
- **กรกฎาคม 2023** | [คู่มือสำหรับนักพัฒนาเกี่ยวกับการออกแบบคำสั่งและ LLMs](https://github.blog/2023-07-17-prompt-engineering-guide-generative-ai-llms/?WT.mc_id=academic-105485-koreyst)
- **กันยายน 2023** | [วิธีสร้างแอป LLM สำหรับองค์กร: บทเรียนจาก GitHub Copilot](https://github.blog/2023-09-06-how-to-build-an-enterprise-llm-application-lessons-from-github-copilot/?WT.mc_id=academic-105485-koreyst)

คุณยังสามารถเรียกดู [บล็อกด้านวิศวกรรม](https://github.blog/category/engineering/?WT.mc_id=academic-105485-koreyst) ของพวกเขาสำหรับโพสต์เพิ่มเติม เช่น [โพสต์นี้](https://github.blog/2023-09-27-how-i-used-github-copilot-chat-to-build-a-reactjs-gallery-prototype/?WT.mc_id=academic-105485-koreyst) ที่แสดงให้เห็นว่าโมเดลและเทคนิคเหล่านี้ถูก _นำไปใช้_ เพื่อขับเคลื่อนแอปพลิเคชันในโลกจริงอย่างไร

---

## การสร้างคำสั่ง

เราได้เห็นแล้วว่าทำไมการออกแบบคำสั่งถึงมีความสำคัญ - ตอนนี้เรามาทำความเข้าใจว่าคำสั่งถูก _สร้างขึ้น_ อย่างไร เพื่อที่เราจะสามารถประเมินเทคนิคต่างๆ สำหรับการออกแบบคำสั่งที่มีประสิทธิภาพมากขึ้น

### คำสั่งพื้นฐาน

เริ่มต้นด้วยคำสั่งพื้นฐาน: ข้อความที่ส่งไปยังโมเดลโดยไม่มีบริบทอื่นใด นี่คือตัวอย่าง - เมื่อเราส่งคำแรกของเพลงชาติสหรัฐอเมริกาไปยัง [Completion API](https://platform.openai.com/docs/api-reference/completions?WT.mc_id=academic-105485-koreyst) ของ OpenAI มันจะ _เติมเต็ม_ คำตอบทันทีด้วยคำถัดไป แสดงให้เห็นถึงพฤติกรรมการคาดการณ์พื้นฐาน

| คำสั่ง (Input)     | การเติมเต็ม (Output)                                                                                                                        |
| :----------------- | :----------------------------------------------------------------------------------------------------------------------------------------- |
| Oh say can you see | ดูเหมือนว่าคุณกำลังเริ่มต้นเนื้อเพลง "The Star-Spangled Banner" ซึ่งเป็นเพลงชาติของสหรัฐอเมริกา เนื้อเพลงทั้งหมดคือ ... |

### คำสั่งที่ซับซ้อน

ตอนนี้เรามาเพิ่มบริบทและคำแนะนำลงในคำสั่งพื้นฐานนั้น [Chat Completion API](https://learn.microsoft.com/azure/ai-services/openai/how-to/chatgpt?WT.mc_id=academic-105485-koreyst) ช่วยให้เราสร้างคำสั่งที่ซับซ้อนในรูปแบบของ _ข้อความ_ ซึ่งประกอบด้วย:

- คู่ข้อความสะท้อนถึง _ข้อความผู้ใช้_ และ _คำตอบของผู้ช่วย_
- ข้อความระบบที่ตั้งค่าบริบทสำหรับพฤติกรรมหรือบุคลิกภาพของผู้ช่วย

คำขอจะอยู่ในรูปแบบด้านล่าง ซึ่ง _tokenization_ จะจับข้อมูลที่เกี่ยวข้องจากบริบทและการสนทนาได้อย่างมีประสิทธิภาพ การเปลี่ยนบริบทของระบบสามารถส่งผลกระทบต่อคุณภาพของการเติมเต็มได้มากพอๆ กับข้อมูลที่ผู้ใช้ให้มา

```python
response = openai.chat.completions.create(
    model="gpt-3.5-turbo",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Who won the world series in 2020?"},
        {"role": "assistant", "content": "The Los Angeles Dodgers won the World Series in 2020."},
        {"role": "user", "content": "Where was it played?"}
    ]
)
```

### คำสั่งแบบมีคำแนะนำ

ในตัวอย่างด้านบน คำสั่งของผู้ใช้เป็นข้อความสอบถามง่ายๆ ที่สามารถตีความได้ว่าเป็นคำขอข้อมูล ด้วยคำสั่งแบบมีคำแนะนำ เราสามารถใช้ข้อความนั้นเพื่อระบุงานในรายละเอียดเพิ่มเติม โดยให้คำแนะนำที่ดีกับ AI นี่คือตัวอย่าง:

| คำสั่ง (Input)                                                                                                                                                                                                                         | การเติมเต็ม (Output)                                                                                                        | ประเภทคำแนะนำ      |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------- | :------------------ |
| เขียนคำอธิบายเกี่ยวกับสงครามกลางเมือง                                                                                                                                                                                                   | _ส่งคืนย่อหน้าเรียบง่าย_                                                                                              | เรียบง่าย              |
| เขียนคำอธิบายเกี่ยวกับสงครามกลางเมือง ระบุวันที่และเหตุการณ์สำคัญและอธิบายความสำคัญของมัน                                                                                                                                     | _ส่งคืนย่อหน้าตามด้วยรายการวันที่เหตุการณ์สำคัญพร้อมคำอธิบาย_                                             | ซับซ้อน             |
| เขียนคำอธิบายเกี่ยวกับสงครามกลางเมืองใน 1 ย่อหน้า ระบุ 3 จุดสำคัญพร้อมวันที่และความสำคัญของมัน ระบุอีก 3 จุดสำคัญเกี่ยวกับบุคคลสำคัญทางประวัติศาสตร์และผลงานของพวกเขา ส่งคืนผลลัพธ์ในรูปแบบไฟล์ JSON | _ส่งคืนรายละเอียดเพิ่มเติมในกล่องข้อความที่จัดรูปแบบเป็น JSON ซึ่งคุณสามารถคัดลอก-วางลงในไฟล์และตรวจสอบได้ตามต้องการ_ | ซับซ้อน. มีรูปแบบ. |

## เนื้อหาหลัก

ในตัวอย่างด้านบน คำสั่งยังคงเปิดกว้างมาก โดยปล่อยให้ LLM ตัดสินใจว่าข้อมูลส่วนใดในชุดข้อมูลที่ได้รับการฝึกอบรมมีความเกี่ยวข้อง ด้วยรูปแบบการออกแบบ _เนื้อหาหลัก_ ข้อความที่ป้อนจะถูกแบ่งออกเป็นสองส่วน:

- คำแนะนำ (การกระทำ)
- เนื้อหาที่เกี่ยวข้อง (ที่มีผลต่อการกระทำ)

นี่คือตัวอย่างที่คำแนะนำคือ "สรุปสิ่งนี้ใน 2 ประโยค"

| คำสั่ง (Input)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | การเติมเต็ม (Output)                                                                                                                                                                                                                                                                             |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ดาวพฤหัสบดีเป็นดาวเคราะห์ดวงที่ห้าจากดวงอาทิตย์และเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะ มันเป็นดาวแก๊สยักษ์ที่มีมวลหนึ่งในพันของดวงอาทิตย์ แต่มีมวลมากกว่าดาวเคราะห์อื่นๆ ในระบบสุริยะรวมกันสองเท่าครึ่ง ดาวพฤหัสบดีเป็นหนึ่งในวัตถุที่สว่างที่สุดที่มองเห็นได้ด้วยตาเปล่าในท้องฟ้ายามค่ำคืน และเป็นที่รู้จักของอารยธรรมโบราณตั้งแต่ก่อนประวัติศาสตร์ มันถูกตั้งชื่อตามเทพเจ้าจูปิเตอร์ของโรมัน [19] เมื่อมองจากโลก ดาวพฤหัสบดีสามารถสว่างพอที่จะสะท้อนแสงจนเกิดเงาที่มองเห็นได้ [20] และโดยเฉลี่ยเป็นวัตถุธรรมชาติที่สว่างที่สุดอันดับสามในท้องฟ้ายามค่ำคืนรองจากดวงจันทร์และดาวศุกร์ <br/> **สรุปสิ่งนี้ใน 2 ประโยคสั้นๆ** | ดาวพฤหัสบดีเป็นดาวเคราะห์ดวงที่ห้าจากดวงอาทิตย์และเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะ มันเป็นดาวแก๊สยักษ์ที่มีมวลมากกว่าดาวเคราะห์อื่นๆ รวมกันสองเท่าครึ่ง และเป็นหนึ่งในวัตถุที่สว่างที่สุดในท้องฟ้ายามค่ำคืนที่มองเห็นได้ด้วยตาเปล่า |

ส่วนเนื้อหาหลักสามารถใช้ในรูปแบบต่างๆ เพื่อขับเคลื่อนคำแนะนำที่มีประสิทธิภาพมากขึ้น:

- **ตัวอย่าง** - แทนที่จะบอกโมเดลว่าต้องทำอะไรด้วยคำแนะนำที่ชัดเจน ให้ตัวอย่างสิ่งที่ต้องทำและปล่อยให้มันอนุมานรูปแบบ
- **คำใบ้** - ตามคำแนะนำด้วย "คำใบ้" ที่ช่วยเริ่มต้นการเติมเต็ม นำทางโมเดลไปสู่คำตอบที่เกี่ยวข้องมากขึ้น
- **แม่แบบ** - สูตรคำสั่งที่สามารถปรับแต่งได้ด้วยข้อมูลสำหรับกรณีการใช้งานเฉพาะ

เรามาสำรวจสิ่งเหล่านี้ในทางปฏิบัติ

### การใช้ตัวอย่าง

นี่คือวิธีที่คุณใช้เนื้อหาหลักเพื่อ "ป้อนโมเดล" ตัวอย่างของผลลัพธ์ที่ต้องการสำหรับคำแนะนำที่กำหนด และปล่อยให้มันอนุมานรูปแบบสำหรับผลลัพธ์ที่ต้องการ ตามจำนวนตัวอย่างที่ให้มา เราสามารถมีการออกแบบคำสั่งแบบ zero-shot, one-shot, few-shot เป็นต้น

คำสั่งตอนนี้ประกอบด้วยสามส่วน:

- คำอธิบายงาน
- ตัวอย่างผลลัพธ์ที่ต้องการ
- จุดเริ่มต้นของตัวอย่างใหม่ (ซึ่งกลายเป็นคำอธิบายงานโดยปริยาย)

| ประเภทการเรียนรู้ | คำสั่ง (Input)                                                                                                                                        | การเติมเต็ม (Output)         |
| :------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------- |
| Zero-shot     | "The Sun is Shining". แปลเป็นภาษาสเปน                                                                                                            | "El Sol está brillando".    |
| One-shot      | "The Sun is Shining" => ""El Sol está brillando". <br> "It's a Cold and Windy Day" =>                                                                 | "Es un día frío y ventoso". |
| Few-shot      | The player ran the bases => Baseball <br/> The player hit an ace => Tennis <br/> The player hit a six => Cricket <br/> The player made a slam-dunk => | Basketball                  |
|               |                                                                                                                                                       |                             |

สังเกตว่าเราต้องให้คำแนะนำที่ชัดเจน ("แปลเป็นภาษาสเปน") ในการออกแบบคำสั่งแบบ zero-shot แต่คำแนะนำจะถูกอนุมานในตัวอย่าง one-shot ตัวอย่าง few-shot แสดงให้เห็นว่าการเพิ่มตัวอย่างมากขึ้นช่วยให้โมเดลทำการอนุมานได้แม่นยำขึ้นโดยไม่ต้องเพิ่มคำแนะนำ

### คำใบ้ในคำสั่ง

อีกเทคนิคหนึ่งสำหรับการใช้เนื้อหาหลักคือการให้ _คำใบ้_ แทนตัวอย่าง ในกรณีนี้ เราให้โมเดลเริ่มต้นด้วยข้อความที่สะท้อนรูปแบบคำตอบที่ต้องการ โมเดลจะ "รับคำใบ้" และดำเนินการต่อในแนวทางนั้น

| จำนวนคำใบ้ | คำสั่ง (Input)                                                                                                                                                                                                                                                                                                                                                                                                                                               | การเติมเต็ม (Output)                                                                                                                                                                                                                                                                                       |
| :------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0              | ดาวพฤหัสบดีเป็นดาวเคราะห์ดวงที่ห้าจากดวงอาทิตย์และเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะ มันเป็นดาวแก๊สยักษ์ที่มีมวลหนึ่งในพันของดวงอาทิตย์ แต่มีมวลมากกว่าดาวเคราะห์อื่นๆ ในระบบสุริยะรวมกันสองเท่าครึ่ง ดาวพฤหัสบดีเป็นหนึ่งในวัตถุที่สว่างที่สุดที่มองเห็นได้ด้วยตาเปล่าในท้องฟ้ายามค่ำคืน และเป็นที่รู้จักของอารยธรรมโบราณตั้งแต่ก่อนประวัติศาสตร์ <br/>**สรุปสิ่งนี้**                                       | ดาวพฤหัสบดีเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะและเป็นดาวเคราะห์ดวงที่ห้าจากดวงอาทิตย์ มันเป็นดาวแก๊สยักษ์ที่มีมวลมากกว่าดาวเคราะห์อื่นๆ รวมกันสองเท่าครึ่ง และเป็นหนึ่งในวัตถุที่สว่างที่สุดในท้องฟ้ายามค่ำคืนที่มองเห็นได้ด้วยตาเปล่า.. |
| 1              | ดาวพฤหัสบดีเป็นดาวเคราะห์ลำดับที่ห้าจากดวงอาทิตย์และเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะ เป็นดาวเคราะห์แก๊สยักษ์ที่มีมวลเพียงหนึ่งในพันของดวงอาทิตย์ แต่มีมวลมากกว่าดาวเคราะห์อื่นๆ ในระบบสุริยะรวมกันถึงสองเท่าครึ่ง ดาวพฤหัสบดีเป็นหนึ่งในวัตถุที่สว่างที่สุดที่สามารถมองเห็นได้ด้วยตาเปล่าในท้องฟ้ายามค่ำคืน และเป็นที่รู้จักของอารยธรรมโบราณตั้งแต่ก่อนมีการบันทึกประวัติศาสตร์ <br/>**สรุปเรื่องนี้** <br/> สิ่งที่เราเรียนรู้คือ ดาวพฤหัสบดี | เป็นดาวเคราะห์ลำดับที่ห้าจากดวงอาทิตย์และเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะ เป็นดาวเคราะห์แก๊สยักษ์ที่มีมวลเพียงหนึ่งในพันของดวงอาทิตย์ แต่มีมวลมากกว่าดาวเคราะห์อื่นๆ รวมกันถึงสองเท่าครึ่ง สามารถมองเห็นได้ด้วยตาเปล่าและเป็นที่รู้จักมาตั้งแต่สมัยโบราณ                        |
| 2              | ดาวพฤหัสบดีเป็นดาวเคราะห์ลำดับที่ห้าจากดวงอาทิตย์และเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะ เป็นดาวเคราะห์แก๊สยักษ์ที่มีมวลเพียงหนึ่งในพันของดวงอาทิตย์ แต่มีมวลมากกว่าดาวเคราะห์อื่นๆ ในระบบสุริยะรวมกันถึงสองเท่าครึ่ง ดาวพฤหัสบดีเป็นหนึ่งในวัตถุที่สว่างที่สุดที่สามารถมองเห็นได้ด้วยตาเปล่าในท้องฟ้ายามค่ำคืน และเป็นที่รู้จักของอารยธรรมโบราณตั้งแต่ก่อนมีการบันทึกประวัติศาสตร์ <br/>**สรุปเรื่องนี้** <br/> 3 ข้อเท็จจริงที่เราเรียนรู้:         | 1. ดาวพฤหัสบดีเป็นดาวเคราะห์ลำดับที่ห้าจากดวงอาทิตย์และเป็นดาวเคราะห์ที่ใหญ่ที่สุดในระบบสุริยะ <br/> 2. เป็นดาวเคราะห์แก๊สยักษ์ที่มีมวลเพียงหนึ่งในพันของดวงอาทิตย์...<br/> 3. ดาวพฤหัสบดีสามารถมองเห็นได้ด้วยตาเปล่าตั้งแต่สมัยโบราณ ...                                                                       |
|                |                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                           |

### แม่แบบคำสั่ง (Prompt Templates)

แม่แบบคำสั่งคือ _สูตรที่กำหนดไว้ล่วงหน้าสำหรับคำสั่ง_ ที่สามารถจัดเก็บและนำกลับมาใช้ใหม่ได้ตามต้องการ เพื่อสร้างประสบการณ์ผู้ใช้ที่สม่ำเสมอในระดับใหญ่ ในรูปแบบที่ง่ายที่สุด มันคือการรวบรวมตัวอย่างคำสั่ง เช่น [ตัวอย่างนี้จาก OpenAI](https://platform.openai.com/examples?WT.mc_id=academic-105485-koreyst) ที่ให้ทั้งส่วนประกอบคำสั่งแบบโต้ตอบ (ข้อความผู้ใช้และข้อความระบบ) และรูปแบบคำขอที่ขับเคลื่อนด้วย API - เพื่อรองรับการใช้งานซ้ำ

ในรูปแบบที่ซับซ้อนยิ่งขึ้น เช่น [ตัวอย่างนี้จาก LangChain](https://python.langchain.com/docs/concepts/prompt_templates/?WT.mc_id=academic-105485-koreyst) มันมี _ตัวแทน_ ที่สามารถแทนที่ด้วยข้อมูลจากแหล่งต่างๆ (ข้อมูลผู้ใช้ บริบทระบบ แหล่งข้อมูลภายนอก ฯลฯ) เพื่อสร้างคำสั่งแบบไดนามิก สิ่งนี้ช่วยให้เราสร้างคลังคำสั่งที่สามารถนำมาใช้เพื่อสร้างประสบการณ์ผู้ใช้ที่สม่ำเสมอ **ในเชิงโปรแกรม** ในระดับใหญ่

สุดท้าย คุณค่าที่แท้จริงของแม่แบบอยู่ที่ความสามารถในการสร้างและเผยแพร่ _คลังคำสั่ง_ สำหรับโดเมนแอปพลิเคชันเฉพาะ - โดยที่แม่แบบคำสั่งได้รับการ _ปรับแต่ง_ เพื่อสะท้อนบริบทหรือตัวอย่างเฉพาะของแอปพลิเคชันที่ทำให้การตอบสนองมีความเกี่ยวข้องและแม่นยำมากขึ้นสำหรับกลุ่มผู้ใช้เป้าหมาย [Prompts For Edu](https://github.com/microsoft/prompts-for-edu?WT.mc_id=academic-105485-koreyst) เป็นตัวอย่างที่ดีของแนวทางนี้ โดยรวบรวมคลังคำสั่งสำหรับโดเมนการศึกษาโดยเน้นวัตถุประสงค์สำคัญ เช่น การวางแผนบทเรียน การออกแบบหลักสูตร การติวสำหรับนักเรียน ฯลฯ

## เนื้อหาสนับสนุน

หากเราคิดว่าการสร้างคำสั่งมีคำแนะนำ (งาน) และเป้าหมาย (เนื้อหาหลัก) _เนื้อหาสนับสนุน_ ก็เหมือนบริบทเพิ่มเติมที่เรามอบให้เพื่อ **มีอิทธิพลต่อผลลัพธ์ในบางวิธี** มันอาจเป็นพารามิเตอร์การปรับแต่ง คำแนะนำการจัดรูปแบบ การจัดหมวดหมู่หัวข้อ ฯลฯ ที่สามารถช่วยให้โมเดล _ปรับแต่ง_ การตอบสนองให้เหมาะสมกับวัตถุประสงค์หรือความคาดหวังของผู้ใช้ที่ต้องการ

ตัวอย่างเช่น: เมื่อมีแคตตาล็อกหลักสูตรที่มีเมตาดาต้าขนาดใหญ่ (ชื่อ คำอธิบาย ระดับ แท็กเมตาดาต้า ผู้สอน ฯลฯ) เกี่ยวกับหลักสูตรทั้งหมดในหลักสูตร:

- เราสามารถกำหนดคำแนะนำเพื่อ "สรุปแคตตาล็อกหลักสูตรสำหรับฤดูใบไม้ร่วง 2023"
- เราสามารถใช้เนื้อหาหลักเพื่อให้ตัวอย่างบางส่วนของผลลัพธ์ที่ต้องการ
- เราสามารถใช้เนื้อหาสนับสนุนเพื่อระบุ "แท็ก" 5 อันดับแรกที่น่าสนใจ

ตอนนี้ โมเดลสามารถให้สรุปในรูปแบบที่แสดงโดยตัวอย่างบางส่วน - แต่ถ้าผลลัพธ์มีหลายแท็ก มันสามารถจัดลำดับความสำคัญของ 5 แท็กที่ระบุในเนื้อหาสนับสนุนได้

---

<!--
แม่แบบบทเรียน:
หน่วยนี้ควรครอบคลุมแนวคิดหลัก #1
เสริมแนวคิดด้วยตัวอย่างและการอ้างอิง

แนวคิด #3:
เทคนิคการออกแบบคำสั่ง
เทคนิคพื้นฐานสำหรับการออกแบบคำสั่งมีอะไรบ้าง?
แสดงให้เห็นด้วยแบบฝึกหัด
-->

## แนวทางปฏิบัติที่ดีที่สุดในการออกแบบคำสั่ง

เมื่อเรารู้แล้วว่าคำสั่งสามารถ _สร้างขึ้น_ ได้ เราสามารถเริ่มคิดเกี่ยวกับวิธีการ _ออกแบบ_ คำสั่งให้สะท้อนแนวทางปฏิบัติที่ดีที่สุด เราสามารถแบ่งออกเป็นสองส่วน - การมี _ทัศนคติ_ ที่ถูกต้องและการใช้ _เทคนิค_ ที่เหมาะสม

### ทัศนคติในการออกแบบคำสั่ง

การออกแบบคำสั่งเป็นกระบวนการทดลองและปรับปรุง ดังนั้นควรคำนึงถึงปัจจัยสำคัญสามประการ:

1. **ความเข้าใจในโดเมนมีความสำคัญ** ความแม่นยำและความเกี่ยวข้องของการตอบสนองเป็นผลมาจาก _โดเมน_ ที่แอปพลิเคชันหรือผู้ใช้ดำเนินการ ใช้สัญชาตญาณและความเชี่ยวชาญในโดเมนของคุณเพื่อ **ปรับแต่งเทคนิค** ให้เหมาะสม เช่น กำหนด _บุคลิกเฉพาะโดเมน_ ในคำสั่งระบบของคุณ หรือใช้ _แม่แบบเฉพาะโดเมน_ ในคำสั่งผู้ใช้ ให้เนื้อหาสนับสนุนที่สะท้อนบริบทเฉพาะโดเมน หรือใช้ _ตัวชี้นำและตัวอย่างเฉพาะโดเมน_ เพื่อแนะนำโมเดลไปสู่รูปแบบการใช้งานที่คุ้นเคย

2. **ความเข้าใจในโมเดลมีความสำคัญ** เรารู้ว่าโมเดลมีลักษณะสุ่มโดยธรรมชาติ แต่การใช้งานโมเดลอาจแตกต่างกันในแง่ของชุดข้อมูลการฝึกอบรมที่ใช้ (ความรู้ที่ฝึกไว้ล่วงหน้า) ความสามารถที่มีให้ (เช่น ผ่าน API หรือ SDK) และประเภทของเนื้อหาที่ได้รับการปรับแต่ง (เช่น โค้ด รูปภาพ หรือข้อความ) เข้าใจจุดแข็งและข้อจำกัดของโมเดลที่คุณใช้ และใช้ความรู้นั้นเพื่อ _จัดลำดับความสำคัญของงาน_ หรือสร้าง _แม่แบบที่ปรับแต่ง_ ซึ่งได้รับการปรับแต่งให้เหมาะสมกับความสามารถของโมเดล

3. **การทำซ้ำและการตรวจสอบมีความสำคัญ** โมเดลกำลังพัฒนาอย่างรวดเร็ว เช่นเดียวกับเทคนิคสำหรับการออกแบบคำสั่ง ในฐานะผู้เชี่ยวชาญในโดเมน คุณอาจมีบริบทหรือเกณฑ์อื่นๆ ที่ _แอปพลิเคชัน_ เฉพาะของคุณอาจต้องการ ซึ่งอาจไม่ใช้กับชุมชนในวงกว้าง ใช้เครื่องมือและเทคนิคการออกแบบคำสั่งเพื่อ "เริ่มต้น" การสร้างคำสั่ง จากนั้นทำซ้ำและตรวจสอบผลลัพธ์โดยใช้สัญชาตญาณและความเชี่ยวชาญในโดเมนของคุณ บันทึกข้อมูลเชิงลึกของคุณและสร้าง **ฐานความรู้** (เช่น คลังคำสั่ง) ที่สามารถใช้เป็นพื้นฐานใหม่โดยผู้อื่น เพื่อการทำซ้ำที่รวดเร็วขึ้นในอนาคต

## แนวทางปฏิบัติที่ดีที่สุด

ตอนนี้เรามาดูแนวทางปฏิบัติที่ดีที่สุดที่แนะนำโดย [OpenAI](https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api?WT.mc_id=academic-105485-koreyst) และผู้ปฏิบัติงาน [Azure OpenAI](https://learn.microsoft.com/azure/ai-services/openai/concepts/prompt-engineering#best-practices?WT.mc_id=academic-105485-koreyst)

| สิ่งที่ควรทำ                     | เหตุผล                                                                                                                                                                                                                                               |
| :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ประเมินโมเดลล่าสุด               | รุ่นใหม่ของโมเดลมีแนวโน้มที่จะมีคุณสมบัติและคุณภาพที่ดีขึ้น - แต่ก็อาจมีค่าใช้จ่ายสูงขึ้นด้วย ประเมินผลกระทบแล้วตัดสินใจว่าจะย้ายไปใช้หรือไม่                                                                                              |
| แยกคำแนะนำและบริบท              | ตรวจสอบว่าโมเดล/ผู้ให้บริการของคุณกำหนด _ตัวแบ่ง_ เพื่อแยกคำแนะนำ เนื้อหาหลัก และเนื้อหาสนับสนุนได้ชัดเจนขึ้นหรือไม่ สิ่งนี้สามารถช่วยให้โมเดลกำหนดน้ำหนักให้กับโทเค็นได้แม่นยำขึ้น                                                         |
| ระบุให้ชัดเจนและเจาะจง          | ให้รายละเอียดเพิ่มเติมเกี่ยวกับบริบทที่ต้องการ ผลลัพธ์ ความยาว รูปแบบ สไตล์ ฯลฯ สิ่งนี้จะช่วยปรับปรุงทั้งคุณภาพและความสม่ำเสมอของการตอบสนอง บันทึกสูตรในแม่แบบที่นำกลับมาใช้ได้                                                          |
| อธิบายและใช้ตัวอย่าง            | โมเดลอาจตอบสนองได้ดีกับวิธี "แสดงและบอก" เริ่มต้นด้วยวิธี `zero-shot` ที่คุณให้คำแนะนำ (แต่ไม่มีตัวอย่าง) จากนั้นลองใช้ `few-shot` เป็นการปรับปรุง โดยให้ตัวอย่างบางส่วนของผลลัพธ์ที่ต้องการ ใช้การเปรียบเทียบเพื่อช่วยอธิบาย |
| ใช้ตัวชี้นำเพื่อเริ่มต้นการตอบสนอง | ชี้นำไปยังผลลัพธ์ที่ต้องการโดยให้คำหรือวลีเริ่มต้นที่สามารถใช้เป็นจุดเริ่มต้นสำหรับการตอบสนอง                                                                                                               |
| ย้ำคำแนะนำ                       | บางครั้งคุณอาจต้องย้ำคำแนะนำกับโมเดล ให้คำแนะนำก่อนและหลังเนื้อหาหลัก ใช้คำแนะนำและตัวชี้นำ ฯลฯ ทำซ้ำและตรวจสอบเพื่อดูว่าอะไรได้ผล                                                                                                         |
| ลำดับมีความสำคัญ                 | ลำดับที่คุณนำเสนอข้อมูลต่อโมเดลอาจส่งผลต่อผลลัพธ์ แม้กระทั่งในตัวอย่างการเรียนรู้ เนื่องจากอคติจากความใหม่ ลองตัวเลือกต่างๆ เพื่อดูว่าอะไรได้ผลดีที่สุด                                                               |
| ให้โมเดลมีทางเลือก               | ให้โมเดลมีคำตอบสำรองที่สามารถให้ได้หากไม่สามารถทำงานให้เสร็จได้ด้วยเหตุผลใดก็ตาม สิ่งนี้สามารถลดโอกาสที่โมเดลจะสร้างคำตอบที่ผิดหรือแต่งขึ้นมาได้                                                         |
|                                   |                                                                                                                                                                                                                                                   |

เช่นเดียวกับแนวทางปฏิบัติที่ดีที่สุดใดๆ โปรดจำไว้ว่า _ผลลัพธ์ของคุณอาจแตกต่างกัน_ ขึ้นอยู่กับโมเดล งาน และโดเมน ใช้สิ่งเหล่านี้เป็นจุดเริ่มต้น และทำซ้ำเพื่อค้นหาสิ่งที่เหมาะสมที่สุดสำหรับคุณ ประเมินกระบวนการออกแบบคำสั่งของคุณอย่างต่อเนื่องเมื่อมีโมเดลและเครื่องมือใหม่ๆ โดยมุ่งเน้นที่ความสามารถในการปรับขนาดกระบวนการและคุณภาพของการตอบสนอง

<!--
แม่แบบบทเรียน:
หน่วยนี้ควรมีการท้าทายโค้ดหากมีความเหมาะสม

การท้าทาย:
ลิงก์ไปยัง Jupyter Notebook ที่มีเพียงคำอธิบายโค้ดในคำแนะนำ (ส่วนโค้ดว่างเปล่า)

คำตอบ:
ลิงก์ไปยังสำเนา Notebook ที่มีคำสั่งเติมเต็มและรัน แสดงตัวอย่างหนึ่งที่เป็นไปได้
-->

## งานที่มอบหมาย

ยินดีด้วย! คุณมาถึงตอนท้ายของบทเรียนแล้ว! ถึงเวลาทดสอบแนวคิดและเทคนิคเหล่านั้นกับตัวอย่างจริง!

สำหรับงานที่มอบหมาย เราจะใช้ Jupyter Notebook ที่มีแบบฝึกหัดที่คุณสามารถทำได้แบบโต้ตอบ คุณยังสามารถขยาย Notebook ด้วยเซลล์ Markdown และ Code ของคุณเองเพื่อสำรวจแนวคิดและเทคนิคด้วยตัวคุณเอง

### เริ่มต้นด้วยการ fork repo แล้ว

- (แนะนำ) เปิด GitHub Codespaces
- (ทางเลือก) Clone repo ไปยังอุปกรณ์ของคุณและใช้กับ Docker Desktop
- (ทางเลือก) เปิด Notebook ด้วยสภาพแวดล้อมการรัน Notebook ที่คุณชื่นชอบ

### จากนั้น ตั้งค่าตัวแปรสภาพแวดล้อมของคุณ

- คัดลอกไฟล์ `.env.copy` ใน root ของ repo ไปยัง `.env` และเติมค่า `AZURE_OPENAI_API_KEY`, `AZURE_OPENAI_ENDPOINT` และ `AZURE_OPENAI_DEPLOYMENT` กลับมาที่ [ส่วน Learning Sandbox](../../../04-prompt-engineering-fundamentals/04-prompt-engineering-fundamentals) เพื่อเรียนรู้วิธีการ

### จากนั้น เปิด Jupyter Notebook

- เลือก kernel runtime หากใช้ตัวเลือก 1 หรือ 2 เพียงเลือก kernel Python 3.10.x เริ่มต้นที่ dev container ให้มา

คุณพร้อมที่จะรันแบบฝึกหัดแล้ว โปรดทราบว่าไม่มี _คำตอบที่ถูกหรือผิด_ ในที่นี้ - เพียงแค่สำรวจตัวเลือกด้วยการทดลองและสร้างสัญชาตญาณสำหรับสิ่งที่เหมาะสมสำหรับโมเดลและโดเมนแอปพลิเคชันที่กำหนด

_ด้วยเหตุนี้จึงไม่มีส่วน Code Solution ในบทเรียนนี้ แต่ Notebook จะมีเซลล์ Markdown ที่ชื่อว่า "My Solution:" ซึ่งแสดงตัวอย่างผลลัพธ์หนึ่งสำหรับการอ้างอิง_

 <!--
แม่แบบบทเรียน:
สรุปส่วนนี้ด้วยบทสรุปและแหล่งข้อมูลสำหรับการเรียนรู้ด้วยตนเอง
-->

## การตรวจสอบความรู้

คำสั่งใดต่อไปนี้เป็นคำสั่งที่ดีตามแนวทางปฏิบัติที่เหมาะสม?

1. แสดงภาพรถสีแดง
2. แสดงภาพรถสีแดงยี่ห้อ Volvo รุ่น XC90 จอดอยู่ริมหน้าผาโดยมีพระอาทิตย์ตกดิน
3. แสดงภาพรถสีแดงยี่ห้อ Volvo รุ่น XC90

คำตอบ: 2 เป็นคำสั่งที่ดีที่สุดเพราะให้รายละเอียดเกี่ยวกับ "อะไร" และลงลึกในรายละเอียด (ไม่ใช่แค่รถใดๆ แต่เป็นยี่ห้อและรุ่นเฉพาะ) และยังอธิบายถึงบรรยากาศโดยรวม 3 เป็นคำสั่งที่ดีรองลงมาเพราะมีคำอธิบายมากเช่นกัน

## 🚀 การท้าทาย

ลองใช้เทคนิค "ตัวชี้นำ" กับคำสั่ง: เติมประโยค "แสดงภาพรถสีแดงยี่ห้อ Volvo และ " ดูว่ามันตอบสนองอย่างไร และคุณจะปรับปรุงคำสั่งนั้นอย่างไร?

## ทำได้ดีมาก! เรียนรู้ต่อไป

ต้องการเรียนรู้เพิ่มเติมเกี่ยวกับแนวคิดการออกแบบคำสั่งต่างๆ หรือไม่? ไปที่ [หน้าการเรียนรู้ต่อเนื่อง](https://aka.ms/genai-collection?WT.mc_id=academic-105485-koreyst) เพื่อค้นหาแหล่งข้อมูลดีๆ อื่นๆ ในหัวข้อนี้

ไปที่บทเรียนที่ 5 ซึ่งเราจะดู [เทคนิคการออกแบบคำสั่งขั้นสูง](../05-advanced-prompts/README.md?WT.mc_id=academic-105485-koreyst)!

---

**ข้อจำกัดความรับผิดชอบ**:  
เอกสารนี้ได้รับการแปลโดยใช้บริการแปลภาษา AI [Co-op Translator](https://github.com/Azure/co-op-translator) แม้ว่าเราจะพยายามให้การแปลมีความถูกต้อง แต่โปรดทราบว่าการแปลอัตโนมัติอาจมีข้อผิดพลาดหรือความไม่ถูกต้อง เอกสารต้นฉบับในภาษาดั้งเดิมควรถือเป็นแหล่งข้อมูลที่เชื่อถือได้ สำหรับข้อมูลที่สำคัญ ขอแนะนำให้ใช้บริการแปลภาษามนุษย์ที่มีความเชี่ยวชาญ เราไม่รับผิดชอบต่อความเข้าใจผิดหรือการตีความผิดที่เกิดจากการใช้การแปลนี้